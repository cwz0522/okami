\ arm.ok - ARM (AArch32) assembler instructions
\ Copyright (C) 2018 Wolfgang Jaehrling
\
\ ISC License
\
\ Permission to use, copy, modify, and/or distribute this software for any
\ purpose with or without fee is hereby granted, provided that the above
\ copyright notice and this permission notice appear in all copies.
\
\ THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
\ WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
\ MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
\ ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
\ WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
\ ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
\ OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

\ requires lib/asm/asm.ok

here not const: reg \ unlikely value to appear by mistake
: r0 [ 0 reg];
: r1 [ 1 reg];
: r2 [ 2 reg];
: r3 [ 3 reg];
: r4 [ 4 reg];
: r5 [ 5 reg];
: r6 [ 6 reg];
: r7 [ 7 reg];
: r8 [ 8 reg];
: r9 [ 9 reg];
: r1 [10 reg];
: r1 [11 reg];
: r1 [12 reg];
: sp [13 reg];
: lr [14 reg];
: ip [15 reg];

here not const: #
: imm       1 25 << {lit} [or];
: setflags  1 20 << {lit} [or]; \ instruction should set the condition flags

: clear-cond  15 28 << not {lit} [and];
: cond: with [28 << ,] does [@ curr.text @ @ clear-cond or curr.text @ !];
: eq [clear-cond] ; \ the rest would be noop, i.e. 0 28 << {lit} [or];
 1 cond: ne
 2 cond: cs
 3 cond: cc
 4 cond: mi
 5 cond: pl
 6 cond: vs
 7 cond: vc
 8 cond: hi
 9 cond: ls
10 cond: ge
11 cond: lt
12 cond: gt
13 cond: le
14 cond: al
15 cond: nv

\\\private{

\ alu ops also need `3 26 << not {lit} [and];` - but that's a noop as bits 26+27 stay unset
: op-and  0 21 << {lit} [or];
: op-eor  1 21 << {lit} [or];
: op-sub  2 21 << {lit} [or];
: op-rsb  3 21 << {lit} [or];
: op-add  4 21 << {lit} [or];
: op-adc  5 21 << {lit} [or];
: op-sbc  6 21 << {lit} [or];
: op-rsc  7 21 << {lit} [or];
: op-tst  8 21 << {lit} [or];
: op-teq  9 21 << {lit} [or];
: op-cmp 10 21 << {lit} [or];
: op-cmn 11 21 << {lit} [or];
: op-orr 12 21 << {lit} [or];
: op-mov 13 21 << {lit} [or];
: op-bic 14 21 << {lit} [or];
: op-mvn 15 21 << {lit} [or];

: alu:rd [reg = assert 12 << aux> or >aux];
: alu:rn [reg = assert 16 << aux> or >aux];

: op2:reg^ [reg =?] if [drop aux> or     >aux rdrop] then ;
: op2:imm^ [#   =?] if [drop aux> or imm >aux rdrop] then ;
: alu:op2  [op2:reg^ op2:imm^ abort];

: instr( [curr.text cell+!] 14 28 << {lit} ;
: )instr [curr.text @ !];

\\\}in{

: arm:and [instr( op-and      >aux alu:rd alu:rn alu:op2 aux> )instr];
: eor [instr( op-eor          >aux alu:rd alu:rn alu:op2 aux> )instr];
: sub [instr( op-sub          >aux alu:rd alu:rn alu:op2 aux> )instr];
: rsb [instr( op-rsb          >aux alu:rd alu:rn alu:op2 aux> )instr];
: add [instr( op-add          >aux alu:rd alu:rn alu:op2 aux> )instr];
: adc [instr( op-adc          >aux alu:rd alu:rn alu:op2 aux> )instr];
: sbc [instr( op-sbc          >aux alu:rd alu:rn alu:op2 aux> )instr];
: rsc [instr( op-rsc          >aux alu:rd alu:rn alu:op2 aux> )instr];
: tst [instr( op-tst setflags >aux alu:rd        alu:op2 aux> )instr];
: teq [instr( op-teq setflags >aux alu:rd        alu:op2 aux> )instr];
: cmp [instr( op-cmp setflags >aux alu:rd        alu:op2 aux> )instr];
: cmn [instr( op-cmn setflags >aux alu:rd        alu:op2 aux> )instr];
: orr [instr( op-orr          >aux alu:rd alu:rn alu:op2 aux> )instr];
: mov [instr( op-mov          >aux alu:rd        alu:op2 aux> )instr];
: bic [instr( op-bic          >aux alu:rd alu:rn alu:op2 aux> )instr];
: mvn [instr( op-mvn          >aux alu:rd        alu:op2 aux> )instr];

: s [curr.text @ @ setflags curr.text @ !];

\\\}

: branch   5 25 << {lit} [or]; \ bit 26 stays unset
: link     1 24 << {lit} [or];
: relative [addr = assert swap &.text:pos -] 1 24 << 1- {lit} [and];

: b  [instr( branch      swap relative or )instr];
: bl [instr( branch link swap relative or )instr];

: swi [instr(] 15 24 << {lit} [or )instr];

\ usage e.g.   r1  r0  r0  add  eq   <=>   addeq r0, r0, r1

' arm:and alias: and  \ makes sense while processing text segment
