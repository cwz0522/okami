\ json.ok - JSON data format processing
\ Copyright (C) 2018 Wolfgang Jaehrling
\
\ ISC License
\
\ Permission to use, copy, modify, and/or distribute this software for any
\ purpose with or without fee is hereby granted, provided that the above
\ copyright notice and this permission notice appear in all copies.
\
\ THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
\ WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
\ MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
\ ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
\ WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
\ ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
\ OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

enum{
  val: jtype.null
  val: jtype.bool
  val: jtype.num
  val: jtype.fix
  val: jtype.str
  val: jtype.ary
  val: jtype.obj
  val: #jtypes
}
: jtype [@];
: jval  [cell+ @];

create: jnull  jtype.null , 0,
create: jtrue  jtype.bool , true ,
create: jfalse jtype.bool , false ,
: jbool if [jtrue] else [jfalse] then ;

defer: json.

private{

\ for now only output to stdout
alias str. str.'
alias emit emit'
alias n.   n.'

str: $null "null"
: jnull. [drop $null str.'];

str: $true "true"
str: $false "false"
: jbool. if [$true] else [$false] then [str.'];

: jnum. [n.'];

: esc. [lit] char \ , [emit'];
: esc: [here docol, [drop esc. lit] swap , [emit]; : [lit] , [,];];
char t esc: t
char n esc: n
char r esc: r
char " esc: "
char \ esc: /
: _ [lit] ' emit' , [,];
create: charmap
  _ _ _ _ _ _ _ _ _ t n _ _ r _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  _ " _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ / _ _ _ _ _ _
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

: str(.  [lit] char " , [emit'];
: )str.  [str(.];
: ascii. [dup cells charmap + @ execute];
: strc.  [128 <?] if [ascii.] else [emit'] then ;
: jstr.  [str(. cell+] begin [dup c@ 0<>?] while [strc. 1+] repeat [)str.];

: ary(.  [lit] char [ , [emit'];
: )ary.  [lit] char ] , [emit'];
: sep.   [lit] char , , [emit'];
: next-> [cell+ @];
: ?sep.  [dup] if [sep.] then ;
: jary.  [ary(.] begin [dup] while [dup @ json. next-> ?sep.] repeat [drop )ary.];

: obj(. [lit] char { , [emit'];
: )obj. [lit] char { , [emit'];
: jobj. [obj(. drop )obj.]; \ TODO

#jtypes array: printers
: json.' [dup jval swap jtype printers @ execute];
' jnull. jtype.null printers !
' jbool. jtype.bool printers !
' jnum.  jtype.num  printers !
' jstr.  jtype.str  printers !
' jary.  jtype.ary  printers !
' jobj.  jtype.obj  printers !

}in{

: jnum  [here jtype.num , swap ,];
: jstr  [here jtype.str , swap ,];
: jary  [here jtype.ary , here 0,];
: jary+ [here swap !    , here 0,];

: jary:each [begin [next-> 0<>?] while [dup >r @]];
: jary:next [[r>] repeat [drop]];

' json.' ' json. is

}
