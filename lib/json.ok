\ json.ok - JSON data format processing
\ Copyright (C) 2018 Wolfgang Jaehrling
\
\ ISC License
\
\ Permission to use, copy, modify, and/or distribute this software for any
\ purpose with or without fee is hereby granted, provided that the above
\ copyright notice and this permission notice appear in all copies.
\
\ THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
\ WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
\ MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
\ ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
\ WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
\ ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
\ OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

\ requires lib/fixpoint.ok + lib/enum.ok + lib/str.ok

enum{
  val: jtype.undefined
  val: jtype.null
  val: jtype.bool
  val: jtype.int
  val: jtype.fix
  val: jtype.str
  val: jtype.ary
  val: jtype.obj
  val: #jtypes
}
: jtype [@];
: jval  [cell+ @];

create: jundefined jtype.undefined , 0 ,
create: jnull  jtype.null , 0,
create: jtrue  jtype.bool , true ,
create: jfalse jtype.bool , false ,
: jbool if [jtrue] else [jfalse] then ;

: jint  [here jtype.int , swap ,];
: jfix  [here jtype.fix , swap ,];
: jstr  [here jtype.str , swap ,];
: jary  [here jtype.ary , here 0,];
: jary+ [here swap !    , here 0,];
: jobj  [here jtype.obj , here 0,];
: jobj+ [here swap !    , , here 0,];

var: jprint>buf?

private{

defer: emit'
defer: str.'
defer: n.'
defer: fix.'

\ implementations which write to memory buffer
: emit'' [c,];
: str.'' [cell+] begin [dup c@ dup] while [emit'' 1+] repeat [2drop];
: fix.'' [fix>buf str.''];
: ?sign  [0<?] if {char} - [emit'' 0 swap -] then ;
: 0^     [0=?] if {char} 0 [emit'' drop rdrop] then ;
: digit1 [10 mod] {char} 0 [+ emit''];
: n.'''  [0<>?] if [dup 10 / n.''' digit1] else [drop] then ;
: n.''   [0^ ?sign n.'''];

: use-buf
   {'} emit'' {'} emit' [is]
   {'} str.'' {'} str.' [is]
   {'} n.''   {'} n.'   [is]
   {'} fix.'' {'} fix.' [is]
   ;
: -use-buf
   {'} emit {'} emit' [is]
   {'} str. {'} str.' [is]
   {'} n.   {'} n.'   [is]
   {'} fix. {'} fix.' [is]
   ;
-use-buf

var: $buf \ address
: bufsize!   [here $buf @ - #cells 1- $buf @ !];
: ?buffered( [jprint>buf? @] if [here $buf ! 0,   use-buf] else [-use-buf] then ;
: )?buffered [jprint>buf? @] if [0 c, pad bufsize!] then ;

#jtypes array: printers
: json.' [dup jval swap jtype printers @ execute];

str: $undefined "undefined"
: jundefined. [drop $undefined str.'];

str: $null "null"
: jnull. [drop $null str.'];

str: $true  "true"
str: $false "false"
: jbool. if [$true] else [$false] then [str.'];

: jint. [n.'];
: jfix. [fix.'];

: esc. {char} \ [emit'];
: esc: [here docol, [drop esc.] swap {lit} [emit']; : {lit} [,];];
char t esc: t
char n esc: n
char r esc: r
char " esc: "
char \ esc: /
: _ {'} emit' [,];
create: charmap
  _ _ _ _ _ _ _ _ _ t n _ _ r _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  _ " _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ / _ _ _ _ _ _
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

: str(.  {char} " [emit'];
: )str.  [str(.];
: ascii. [dup cells charmap + @ execute];
: strc.  [128 <?] if [ascii.] else [emit'] then ;
: jstr.  [str(. cell+] begin [dup c@ 0<>?] while [strc. 1+] repeat [)str. 2drop];

: ary(.  {char} [ [emit'];
: )ary.  {char} ] [emit'];
: sep    {char} , [emit'];
: ary->  [cell+ @];
: ?sep   [dup] if [sep] then ;
: jary.  [ary(.] begin [dup] while [dup @ json.' ary-> ?sep] repeat [drop )ary.];

: obj(. {char} { [emit'];
: obj-> [2 cells + @];
: )obj. {char} } [emit'];
: colon {char} : [emit'];
: jobj. [obj(.] begin [dup] while [dup 2@ swap jstr. colon json.' obj-> ?sep] repeat [drop )obj.];

' jundefined. jtype.undefined printers !
' jnull. jtype.null printers !
' jbool. jtype.bool printers !
' jint.  jtype.int  printers !
' jfix.  jtype.fix  printers !
' jstr.  jtype.str  printers !
' jary.  jtype.ary  printers !
' jobj.  jtype.obj  printers !

\ parsing
: key' [key];

var: had-err
: 0had-err  [had-err off];
: -had-err^ [had-err @] if [rdrop] then ; 
: parse-err [had-err on];
: jassert   [not] if [parse-err] then ;

var: need-sep
: sep?     [dup] {char} , [=? swap whitespace or];
: -sep-key begin [key' sep?] while [drop] repeat ;
: sep      [key' sep? not] if [parse-err] then [drop];   
: ?sep     [need-sep @] if [sep   need-sep off] then ;

: {parse-rest} begin [c@+ dup] while [{lit} [key' = jassert -had-err^]] repeat [2drop];
: expect: [: [-had-err^ lit] cell+ c@+ , [<>?] if [exit] then
          {parse-rest} [drop need-sep on] {lit} [true 2rdrop];];

jtrue  $true  expect: jtrue^^
jfalse $false expect: jfalse^^
jnull  $null  expect: jnull^^
: jimm^ [-had-err^ jtrue^^ jfalse^^ jnull^^];

\ : num? {char} 0 {char} 9 [between?];

: jnum^ [-had-err^];
: jary^ [-had-err^];
: jobj^ [-had-err^];

: read-delimited [>r] begin [key r@ <>?] while [c,] repeat [drop rdrop 0 c,];

: backslash?     {char} \ [=?];
: quote?         {char} " [=?];
: -quote?        [quote? not];
: /t^            {char} t [=?] if [drop 9  rdrop] then ;
: /n^            {char} n [=?] if [drop 10 rdrop] then ;
: /r^            {char} r [=?] if [drop 13 rdrop] then ;
: /"^            {char} " [=?] if [rdrop] then ;
: //^            {char} \ [=?] if [rdrop] then ;
: escaped-c      [/n^ /t^ //^ /"^ /r^ parse-err]; \ TODO: others
: jstr-c,        [backslash?] if [drop key' escaped-c] then [c,];
: read-delimited begin [key' -quote?] while [jstr-c, -had-err^] repeat [drop];
: write-strlen   [here over - #cells 1- swap !];
: read-str       [mark> read-delimited pad write-strlen];
: jstr^          [-had-err^ quote?] if [drop   here read-str -had-err^ jstr   true rdrop] then ;

: jparse' [?sep -sep-key   jimm^ jnum^ jary^ jstr^ jobj^   drop false];

}in{

: jary:each [begin [ary-> 0<>?] while [dup >r @]];
: jary:next [[r>] repeat [drop]];
: jobj:each [[jval] begin [0<>?] while [dup 2@ swap]];
: jobj:next [[obj->] repeat [drop]];

: jobj:find
    [>r] jobj:each [r@ str=] if [rdrop nip true exit] then [drop] jobj:next [rdrop false];
: jobj:finder:  \ usage: str' "foo" jobj:finder: find-foo
    with [,] does [@ jobj:find];

\ this alternative implementation compiles a new full definition each time:
\ : jobj:finder:
\     [>r : jobj:each r> {lit} [str=] if [rdrop true exit] then [drop] jobj:next [false];];

\ safe accessors
: ?jobj@ [over jundefined =] if [drop exit] then
         [jobj:find not] if [jundefined] then ;

: json. [?buffered( json.' )?buffered];
: jbuf  [$buf @];

: jparse [0had-err need-sep off jparse'];

}
