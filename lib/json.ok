\ json.ok - JSON data format processing
\ Copyright (C) 2018 Wolfgang Jaehrling
\
\ ISC License
\
\ Permission to use, copy, modify, and/or distribute this software for any
\ purpose with or without fee is hereby granted, provided that the above
\ copyright notice and this permission notice appear in all copies.
\
\ THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
\ WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
\ MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
\ ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
\ WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
\ ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
\ OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

\ requires lib/fixpoint.ok + lib/enum.ok

enum{
  val: jtype.null
  val: jtype.bool
  val: jtype.int
  val: jtype.fix
  val: jtype.str
  val: jtype.ary
  val: jtype.obj
  val: #jtypes
}
: jtype [@];
: jval  [cell+ @];

create: jnull  jtype.null , 0,
create: jtrue  jtype.bool , true ,
create: jfalse jtype.bool , false ,
: jbool if [jtrue] else [jfalse] then ;

defer: json.

private{

\ for now only output to stdout
alias str. str.'
alias emit emit'
alias n.   n.'
alias fix. fix.'

str: $null "null"
: jnull. [drop $null str.'];

str: $true  "true"
str: $false "false"
: jbool. if [$true] else [$false] then [str.'];

: jint. [n.'];
: jfix. [fix.'];

: esc. {char} \ [emit'];
: esc: [here docol, [drop esc.] swap {lit} [emit]; : {lit} [,];];
char t esc: t
char n esc: n
char r esc: r
char " esc: "
char \ esc: /
: _ {'} emit' [,];
create: charmap
  _ _ _ _ _ _ _ _ _ t n _ _ r _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  _ " _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ / _ _ _ _ _ _
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

: str(.  {char} " [emit'];
: )str.  [str(.];
: ascii. [dup cells charmap + @ execute];
: strc.  [128 <?] if [ascii.] else [emit'] then ;
: jstr.  [str(. cell+] begin [dup c@ 0<>?] while [strc. 1+] repeat [)str. 2drop];

: ary(.  {char} [ [emit'];
: )ary.  {char} ] [emit'];
: sep    {char} , [emit'];
: ary->  [cell+ @];
: ?sep   [dup] if [sep] then ;
: jary.  [ary(.] begin [dup] while [dup @ json. ary-> ?sep] repeat [drop )ary.];

: obj(. {char} { [emit'];
: obj-> [2 cells + @];
: )obj. {char} } [emit'];
: colon {char} : [emit'];
: jobj. [obj(.] begin [dup] while [dup 2@ swap jstr. colon json. obj-> ?sep] repeat [drop )obj.];

#jtypes array: printers
: json.' [dup jval swap jtype printers @ execute];
' jnull. jtype.null printers !
' jbool. jtype.bool printers !
' jint.  jtype.int  printers !
' jfix.  jtype.fix  printers !
' jstr.  jtype.str  printers !
' jary.  jtype.ary  printers !
' jobj.  jtype.obj  printers !

}in{

: jint  [here jtype.int , swap ,];
: jfix  [here jtype.fix , swap ,];
: jstr  [here jtype.str , swap ,];
: jary  [here jtype.ary , here 0,];
: jary+ [here swap !    , here 0,];
: jobj  [here jtype.obj , here 0,];
: jobj+ [here swap !    , , here 0,];

: jary:each [begin [ary-> 0<>?] while [dup >r @]];
: jary:next [[r>] repeat [drop]];
: jobj:each [[jval] begin [0<>?] while [dup >r 2@ swap]];
: jobj:next [[r> obj->] repeat [drop]];
: jobj:find [swap] jobj:each [swap >r str=?] if [drop r> rdrop true exit] then [rdrop] jobj:next [drop false];

' json.' ' json. is

}
