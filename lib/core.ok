\ core.ok - basic definitions for okami
\ Copyright (C) 2018 Wolfgang Jaehrling
\
\ ISC License
\
\ Permission to use, copy, modify, and/or distribute this software for any
\ purpose with or without fee is hereby granted, provided that the above
\ copyright notice and this permission notice appear in all copies.
\
\ THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
\ WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
\ MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
\ ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
\ WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
\ ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
\ OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

dp @ \ for dict-end

entry: : docol, [entry: docol, exit]
\ : ; [[exit] exit]
: ; [[exit] hp @ dp @ dup @ 2 + 4 * + ! exit]

: dict-end [lit] , ;

: here [hp @];
: 0, [0 ,];

: mark>    [here 0,];
: resolve> [here swap !];

: if   [[0branch] mark>];
: then [resolve>];
: else [[branch] mark> >r resolve> r>];

: begin  [here];
: while  [[0branch] mark>];
: repeat [[branch] swap , resolve>];
: until  [[0branch] ,];
: rfor   [[>r] here [r@ <>? 0branch] mark> swap];
: next   [[branch] , resolve> [rdrop drop]];

: char [key drop key];
: (    begin [key lit] char ) , [<>] while repeat ;

: create: [entry: dopush,];
: with    [[entry: dodoes, lit] mark> [,]];
: does    [[exit] resolve>];

: const: with [,] does [@];
: var:   [create: 0,];

: yield [rswap];
: 2rdrop [r> rdrop rdrop >r];

4 const: cell
: cells  [cell *];
: cell+  [cell +];
: cell-  [cell -];
: #cells [cell /];

-1 const: true
0  const: false
: on  [true  swap !];
: off [false swap !];

: 1+     [1 +];
: 1-     [1 -];
: +!     [tuck @ + swap !];
: 1+!    [1 swap +!];
: c@+    [dup 1+ swap c@];
: c!+    [tuck c! 1+];
: 0=     [0 =];
: 0=?    [dup 0 =];
: 0<>    [0 <>];
: 0<>?   [dup 0 <>];
: 0<     [0 <];
: 0<?    [dup 0 <];
: 0>     [0 >];
: 0>?    [dup 0 >];
: 0<=    [0 <=];
: 0<=?   [dup 0 <=];
: 0>=    [0 >=];
: 0>=?   [dup 0 >=];
: negate [0 swap -];

: '     [word find];
: alias [here  ' hp ! entry:  hp !];

: {lit}  [[lit] ,];
: {char} [char {lit}];
: {'}    [' {lit}];

: ?dup  [dup] if [dup] then ;
: 2drop [drop drop];
: 2@    [dup @ swap cell+ @]; \ addr -- @addr @next
: ?if   [[?dup] if];

32 const: bl
: space  [bl emit];
: spaces [0 swap] rfor [space 1+] next ;
: cr     [10 emit];
: .      [n. space];

: ?    [@ .];
: bye  [0 sysexit];
: fail [1 sysexit];

: abs      [0<?] if [negate] then ;
: between  [>r >=? swap r> <= and];
: between? [>r >=? over r> <= and];
: max      [2dup >] if [drop] else [nip] then ;
: min      [2dup <] if [drop] else [nip] then ;

: mod [/mod drop];

: array: with [cells allot] does [swap cells +];

: aligned   [2dup mod 0=?] if [2drop] else [- +] then ;
: align     [here swap aligned hp !];
: -aligned  [1- here and 0<>];
: pad       begin [cell -aligned] while [0 c,] repeat ;

: str.  [cell+] begin [dup c@ dup 0<>] while [emit 1+] repeat [2drop];
: str,  [here copy-str  @ cells allot];
: str<> [str= not];
: str=? [over str=];

var: (undef-defer) \ value given later when we can create strings
: undef-defer [(undef-defer) @ str. cr];
: defer:      [: [undef-defer];];
: is          [cell+ !];

defer: }  ' } const: '}
: open{  ['} cell+ @ swap '} is]; 
: close} ['} is];

: >dp      [dp @ cell- dup dp ! !];
: }private [close}   !];
           ' }private const: '}private
: private{ [dp @];
: }in{     [dp @ >dp   dp @   0 >dp   '}private open{];

private{
  : delimiter      begin [key bl =?] while [drop] repeat ;
  : read-delimited [>r] begin [key r@ <>?] while [c,] repeat [drop rdrop 0 c,];
  : write-strlen   [here over - #cells 1- swap !];
  : read-str       [mark>  delimiter read-delimited  pad  write-strlen];
}in{
: str' [here read-str];
: str: with [read-str] does [];
}
str' "deferred word used but not defined." (undef-defer) !

: }struct with [, close}] does [@ here swap allot const:];
          ' }struct const: '}struct
: struct{      ['}struct open{   0];
: field   with [over , +] does [@ +];
: offset       [dup const:];

\ useful for jump tables:
: perform [@] ?if [execute] then ;

defer: abort
' fail ' abort is
str: $assert "assertion failed!"
: assert   [not] if [$assert str. cr abort] then ;
: ?assert [dup assert];
