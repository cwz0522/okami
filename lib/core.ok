\ core.ok - basic definitions for okami
\ Copyright (C) 2018 Wolfgang Jaehrling
\
\ ISC License
\
\ Permission to use, copy, modify, and/or distribute this software for any
\ purpose with or without fee is hereby granted, provided that the above
\ copyright notice and this permission notice appear in all copies.
\
\ THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
\ WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
\ MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
\ ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
\ WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
\ ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
\ OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

dp @ \ for dict-end

entry : docol, [entry docol, exit]
\ : ; [[exit] exit]
: ; [[exit] hp @ dp @ dup @ 2 + 4 * + ! exit]

: dict-end [lit] , ;

: here [hp @];
: 0, [0 ,];

: mark>    [here 0,];
: resolve> [here swap !];

: if   [[0branch] mark>];
: then [resolve>];
: else [[branch] mark> >r resolve> r>];

: begin  [here];
: while  [[0branch] mark>];
: repeat [[branch] swap , resolve>];
: until  [[0branch] ,];
: rfor   [[>r] here [r@ <>? 0branch] mark> swap];
: next   [[branch] , resolve> [rdrop drop]];

: char [key drop key];
: (    begin [key lit] char ) , [<>] while repeat ;

: create [entry dopush,];
: with   [[entry dodoes, lit] mark> [,]];
: does   [[exit] resolve>];

: const with [,] does [@];
: var [create 0,];

: yield [rswap];

4 const cell
: cells  [cell *];
: cell+  [cell +];
: cell-  [cell -];
: #cells [cell /];

-1 const true
0  const false
: on  [true  swap !];
: off [false swap !];

: 1+     [1 +];
: 1-     [1 -];
: +!     [tuck @ + swap !];
: 1+!    [1 swap +!];
: c@+    [dup 1+ swap c@];
: 0=     [0 =];
: 0=?    [dup 0 =];
: 0<>    [0 <>];
: 0<>?   [dup 0 <>];
: 0<     [0 <];
: 0<?    [dup 0 <];
: 0>     [0 >];
: 0>?    [dup 0 >];
: 0<=    [0 <=];
: 0<=?   [dup 0 <=];
: 0>=    [0 >=];
: 0>=?   [dup 0 >=];
: negate [0 swap -];

: '     [word find];
: alias [here  ' hp ! entry  hp !];

: ?    [@ .];
: bye  [0 sysexit];
: fail [1 sysexit];

: ?dup  [dup] if [dup] then ;
: 2drop [drop drop];
: 2@    [dup @ swap cell+ @]; \ addr -- @addr @next
: ?if   [[?dup] if];

32 const bl
: space  [bl emit];
: spaces [0 swap] rfor [space 1+] next ;
: cr     [10 emit];

: abs      [0<?] if [negate] then ;
: between  [>r >=? swap r> <= and];
: between? [>r >=? over r> <= and];
: max      [2dup >] if [drop] else [nip] then ;
: min      [2dup <] if [drop] else [nip] then ;

: mod [/mod drop];

: array with [cells allot] does [swap cells +];

: aligned \ value alignment --
    [2dup mod 0=?] if [2drop] else [- +] then ;
: align [hp @ swap aligned hp !];

: str.  [cell+] begin [dup c@ dup 0<>] while [emit 1+] repeat [2drop];
: str<> [str= not];

var (undef-defer) \ value given later when we can create strings
: undef-defer [(undef-defer) @ str. cr];
: defer       [: [undef-defer exit]];
: is          [cell+ !];

defer }  ' } const '}
: open{  ['} cell+ @ swap '} is]; 
: close} ['} is];

: }struct with [, close}] does [@ here swap allot const];  ' }struct const '}struct
: struct{      ['}struct open{   0];
: field  with  [over , +] does [@ +];
: offset       [dup const];

: >dp      [dp @ cell- dup dp ! !];
: }private [close}   !];  ' }private const '}private
: private{ [dp @];
: }in{     [dp @ >dp   dp @   0 >dp   '}private open{];

private{
  : (read-delimited) [key >r] begin [key r@ <>?] while [c,] repeat [drop rdrop];
  : (write-strlen)   [here over - #cells 1- swap !];
  : (read-str)       [mark>  key drop  (read-delimited)  cell align  (write-strlen)];
}in{
: str' [here (read-str)];
: str  with [(read-str)] does [];
}
str' "deferred word used but not defined." (undef-defer) !

\ useful for jump tables:
: perform [@] ?if [execute] then ;

: backtrace ; \ noop to allow aborting words to use it
