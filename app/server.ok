\ server.ok - HTTP server
\ Copyright (C) 2018 Wolfgang Jaehrling
\
\ ISC License
\
\ Permission to use, copy, modify, and/or distribute this software for any
\ purpose with or without fee is hereby granted, provided that the above
\ copyright notice and this permission notice appear in all copies.
\
\ THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
\ WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
\ MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
\ ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
\ WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
\ ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
\ OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

8086 config:server-port !
config:remote-access off
tcpipv6-server

private{
  256 const: /line
  create: request-line /line allot
  create: header-line  /line allot
  var: line'
}in{
: request [request-line line' !];
: header  [header-line  line' !];
: line    [line' @];
}

: dropcr  [13 =?] if [drop getreqb] then ;
: -crlf?  [dropcr 10 <>?];
: fill-line
    [line] begin [getreqb -crlf?] while [over c! 1+] repeat
    [drop 0 swap c!];

\ headers
var: content-length
var: connection:close
private{

  : skip-bl begin [1+ dup c@ bl <>] until ;
  var: header-name
  var: header-val
  : name&val! [2dup skip-bl header-val ! header-name !];

  : upper?         {char} A [>=? over] {char} Z [<= and];
  : upper>lower    [lit] char a char A - , [+];
  : -upcase        [upper?] if [upper>lower] then ;
  : downcase-range rfor [dup c@ -upcase over c! 1+] next ;

  : -eol^        [0=?] if [drop rdrop] then ;
  : -colon?      {char} : [<>];
  : search-colon [line] begin [dup c@ -eol^ -colon?] while [1+] repeat ;
  : found?       [dup c@ 0<>];
  : parse-hdr    [line search-colon found?] if [name&val! downcase-range] then ;

  \ individual header types
  : content-length! [cs>n content-length !];
  : connection!     [drop connection:close off]; \ TODO

  : hdr:            [: {lit} [str-at?] if [header-val @] swap , [rdrop] then ;];

  ' content-length! str' "content-length:" hdr: content-length^
  ' connection!     str' "connection:"     hdr: connection^

  : either-of ;
  : ignore [drop];
  : -empty [line c@ 0<>];

  : interpret-hdr [header-name @] either-of
      [content-length^ connection^ ignore];

}in{
: hdrs [header] begin [fill-line -empty] while [parse-hdr interpret-hdr] repeat ;
}

\ request parsing
var: method'
var: url'
var: proto-version'
var: body-start
var: body-end
: start-http         [0 filled !  0 processed !];
: past-next-bl       [find-bl 1+];
: method             [dup method'    !  past-next-bl];
: url                [dup url'       !  past-next-bl];
: proto-version      [proto-version' !];
: parse-request-line [line method url proto-version];
: request-line       [request fill-line parse-request-line];
: getreqdata         [0] rfor [getreqb c, 1-] next ;
: payload            [here body-start !   content-length @ getreqdata   here body-end !];
: parse-request      [start-http request-line hdrs payload];

: bad-request [abort];

defer: request>response
: body>json    [body-start @ body-end @ jparsebuf! jparse];
: create-reply [body>json] if [request>response] else [bad-request] then ;

str: $response:ok       "HTTP/1.1 200 OK"
str: $connection:close  "Connection: close"
str: $content-type:json "Content-type: text/json"
str: $content-length    "Content-length: ____"
str: $sep               ""
$content-length 20 + const: 'content-length-val
: +newline           [dup 10 swap c! 1+];
: str>len&start      [cdata +newline over - swap];
: send-line          [MSG_NOSIGNAL swap str>len&start  client socket @  send(syscall) succeed];
: digit1             [10 mod] {char} 0 [+ c,];
: n>hdr              [0<>?] if [dup 10 / n>hdr digit1] else [drop 0 c, 0 c, 0 c,] then ;
: body-len           [dup cdata swap -];
: set-content-length [here >r 'content-length-val hp !   body-len n>hdr  r> hp !];
: content-length-hdr [set-content-length $content-length    send-line];
: response-line      [                   $response:ok       send-line];
: connection-hdr     [                   $connection:close  send-line];
: content-type-hdr   [                   $content-type:json send-line];
: response-body      [$sep send-line send-line];
: send-response      [json>buf response-line
                      connection-hdr content-type-hdr content-length-hdr
                      response-body];

: region( [here];
: )region [hp !];

: handle-request [region( parse-request create-reply send-response )region];

: nop [];
' nop ' request>response is

handle-request

\ : print-buf [filled @ >r requestbuf] begin [r> 1- 0<>?] while [>r c@+ emit] repeat [2drop];
\ print-buf

\ send it back!
\ MSG_NOSIGNAL /requestbuf requestbuf  client socket @  send(syscall) succeed

bye
