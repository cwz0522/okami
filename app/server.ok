\ server.ok - HTTP/TCP/IPv6 server
\ Copyright (C) 2018 Wolfgang Jaehrling
\
\ ISC License
\
\ Permission to use, copy, modify, and/or distribute this software for any
\ purpose with or without fee is hereby granted, provided that the above
\ copyright notice and this permission notice appear in all copies.
\
\ THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
\ WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
\ MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
\ ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
\ WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
\ ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
\ OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

\ server configuration:
\ only loopback device connections?
false const allow-remote-access

struct{
  2    field family
  2    field port
  cell field flowinfo
  16   field ipv6addr
  cell field scope
       offset /sockaddr_in6
  cell field socket
} endpoint

endpoint server
endpoint client

: succeed [0<?] if [errno. cr 1 sysexit] then [drop];

: tcp/ipv6-socket [IPPROTO_IP SOCK_STREAM PF_INET6 socket(syscall) dup succeed];
tcp/ipv6-socket server socket !

var yes  true yes !  \ need this to pass an address to syscalls

\ use port even if it was used within the last minutes:
cell yes SO_REUSEADDR SOL_SOCKET  server socket @  setsockopt(syscall)  succeed

\ IPv6 only, no dual stack:
cell yes IPV6_V6ONLY IPPROTO_IPV6  server socket @  setsockopt(syscall)  succeed

\ : htons [dup 255 and 8 << swap 255 not and 8 >> or];
: net-h! [2dup  swap 8 >> swap c!  1+ c!]; \ set halfword in network byte order
: h!     [2dup  c!  1+ swap 8 >> swap c!]; \ set halfword

AF_INET6 server family h!
8080     server port   net-h!
: config-access [allow-remote-access not] if [1 server ipv6addr 15 + c!] then ;
config-access

/sockaddr_in6 server  server socket @  bind(syscall)  succeed

5 const backlog
\ *** Here comes the part we should do in a loop ***
backlog  server socket @  listen(syscall)  succeed

var (/sockaddr_in6) \ may be changed by `accept` syscall
/sockaddr_in6 (/sockaddr_in6) !
(/sockaddr_in6) client  server socket @  accept(syscall)  dup succeed  client socket !

\ here we could log the client address

4096 const /requestbuf
create requestbuf /requestbuf allot
var filled
var processed

: recv [MSG_NOSIGNAL /requestbuf requestbuf  client socket @  recv(syscall)
        dup succeed filled ! 0 processed !];
: peekreqb [filled @ processed @  =] if [recv] then [requestbuf processed @ + c@];
: getreqb [peekreqb  1 processed +!];

256 const /line
create request-line /line allot
var (line)
: request [request-line (line) !];
: line [(line) @];

: -crlf? [10 =? >r 13 =? r> or not];
: skip-lf [peekreqb 10 =] if [getreqb drop] then ;
: fill-line
    [line] begin [getreqb -crlf?] while [over c! 1+] repeat
    [drop 0 swap c!  skip-lf];

: start-http [0 filled !  0 processed !];
: fwd-past \ addr c -- addr'
    [>r] begin [dup c@ r@ <>] while [1+] repeat [1+ rdrop];
var http-method
: method [dup http-method !  bl fwd-past];
var http-url
: url [dup http-url !  bl fwd-past];
var http-proto-version
: proto-version [http-proto-version !];
: parse-request-line [line method url proto-version];
: request-line [request fill-line parse-request-line];
: parse-request [start-http request-line];

parse-request

: print-buf [filled @ >r requestbuf] begin [r> 1- 0<>?] while [>r c@+ emit] repeat [2drop];
\ print-buf

\ send it back!
\ MSG_NOSIGNAL /requestbuf requestbuf  client socket @  send(syscall) succeed

\ bye
